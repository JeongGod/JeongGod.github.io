---
layout: post
title:  "ORM과 JPA에 대해서"
subtitle:   "Spring Boot - ORM&JPA"
categories: study
tags: spring spring-boot ORM JPA
comments: true
# header-img: ""
---

- 목차
	- [ORM](#orm)
    - [JPA는 뭐야?](#jpa는-뭐야)
    - [영속성 컨텍스트란](#영속성-컨텍스트란)

## ORM

- ORM (Object-Relational Mapping)으로 객체와 관계형 데이터베이스 매핑, 객체와 DB의 테이블이 매핑을 이루는 것이다.
- SQL Query가 아닌 직관적인 코드(메서드)로서 데이터를 조작할 수 있다.
- 객체와 쿼리를 분리하여 복잡도를 줄이고, 트랜잭션 처리나 기타 데이터베이스 관련작업들을 좀 더 편리하게 처리할 수 있는 방법이다.

## JPA는 뭐야?

- Java Persistence API로 자바 ORM기술에 대한 API표준 명세이다.
- ORM을 사용하기 위한 인터페이스를 모아둔 것이다.
- 자바 어플리케이션에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스다.
- "인터페이스"이기 때문에 JPA를 사용하기 위해서는 JPA를 구현한 Hibernate, EclipseLink, DataNucleus와 같은 ORM 프레임워크를 사용해야 한다.

⭐️ JPA의 특징으로는 **ORM**, **영속성 컨텍스트**다.이 2가지가 주요 특징이다!

### JPA의 장점

1. 생산성이 뛰어나고 유지보수가 용이하다. 객체 중심 설계에 더 집중할 수 있기 때문이다.
2. DBMS에 대한 종속성이 줄어든다.   
⇒ DB쿼리문을 코드단에서 해결이 가능하다. DBMS에서 DB만 생성하고, 테이블 생성&관리등 많은 부분들을 코드단에서 관리가 가능하다.

### JPA의 단점

1. JPA를 학습하려면 많은 노력이 든다.
2. 복잡한 쿼리를 사용할 경우 불리하다.   
⇒ 하나의 테이블에서는 이 정보, 다른 테이블에서는 이 정보를 가져와 하나의 데이터 객체로 만들기가 어렵다. SQL문에서는 join함수로 쿼리 한 줄이면 끝난다.
3. 잘못 사용하면 성능이 떨어질 수도 있다.

## 영속성 컨텍스트란

**엔티티를 영구 저장하는 환경**이라고 한다. EntityManger를 통해 영속성 컨텍스트에 접근한다.

- 같은 트랜잭션내에 EntityManger가 여러개 생긴다면 모두 하나의 "영속성 컨텍스트"를 바라본다.

트랜잭션이 시작한 후에 객체(Entity)를 생성하게 되면, 해당 객체(Entity)는 "영속성 컨텍스트"에 저장 및 관리가 이루어진다. 이 때 DB에 저장이 되는 상태는 아니다!!! 쿼리가 날라가지 않는다!!! 그냥 "영속성 컨텍스트"에 저장이 이루어져 있을 뿐이다.

트랜잭션이 끝나면 영속성 컨텍스트에 저장되어있던 변경사항들이 쿼리로 변환되어 DB에 날라간다. 자세한 내용은 밑에 말한다.

### 영속성 컨텍스트의 이점

- 영속성 컨텍스트 내부에는 1차 캐시가 존재한다.
- Entity를 영속성 컨텍스트에 저장하면 1차 캐시에 저장이 된다. 
(key, value)쌍으로 key = PK, value = Entity
- 1차 캐시로 DB조회가 이루어질 때 Entity가 1차 캐시에 존재한다면 굳이 DB까지 가지 않아도 바로 객체를 찾아올 수 있다.
- 만약 존재하지 않으면 DB에서 꺼내와 1차 캐시에 저장한다.
- 그렇게 되면 DB에 쿼리를 직접 날리지 않고도 객체를 찾아올 수 있다.
- 동일성을 보장한다. 만일 member1을 2번 조회한다 한들, 1차 캐시에서 참조하는 것이기 때문에 같은 주소값을 지닌다!!

이렇게 영속성 컨텍스트에 넣으면 좋은 점은 바로바로 DB에 쿼리를 날리지 않고 한 번에 날린다는 점이다.

`쓰기 지연 SQL저장소`라는 곳에 쿼리들을 넣어 놓고, 트랜잭션이 끝나면 한꺼번에 쿼리를 날린다.

⭐️ 만약 Entity에서 수정이 일어났다면?

### Dirty Checking

더티 체킹을 이용한다. 변경 감지라는 것이다. 위에 1차 캐시에 "스냅샷 필드"도 저장되는데 트랜잭션을 `commit()` or `flush()`가 일어난다면 "Entity"와 "스냅샷"을 비교하여 변경사항이 있으면 알아서 SQL 쿼리문을 날려준다.

commit()시에는 flush()가 자동 호출된다.

flush()는 DB에게 위에서 저장된 `쓰기 지연 SQL저장소`에 있는 쿼리문을 날리는 역할이다.
영속성 컨텍스트를 비우는 역할은 하지 않는다. 

> 출처   
[https://ict-nroo.tistory.com/130](https://ict-nroo.tistory.com/130)   
[https://goddaehee.tistory.com/209](https://goddaehee.tistory.com/209)